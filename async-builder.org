
* New
** consult-gh
#+begin_src emacs-lisp
(defvar my:consult-gh-args '("gh" "search repos"))

;; (defun my:consult-gh--builder (repo)
;; `("gh" "search" "repos" ,(format "%s" repo)))

;; (defun my:consult-gh--make-builder (input)
;;   "Build find command line, finding across PATHS."
;;   (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
;;                (`(,re . ,hl) (funcall consult--regexp-compiler arg 'basic t)))
;;     (cons (append (consult--build-args my:consult-gh-args) opts)
;;           hl)))

(defun my:consult-gh--make-builder (input)
  "Build command line from INPUT."
  (pcase-let ((`(,arg . ,opts) (consult--command-split input)))
    (unless (string-blank-p arg)
      (append (consult--build-args my:consult-gh-args)
              (list arg) opts))))

(defun my:consult-gh--async (prompt make-builder)
  (consult--read
     (consult--async-command make-builder
       :buffer (get-buffer-create "*consult-gh-output*") :stderr (get-buffer-create "*consult-gh-error*"))
     :prompt prompt
     :require-match nil
     :category 'consult-gh
     :sort nil))

(defun my:consult-gh-async ()
  (interactive)
  (my:consult-gh--async "Search Repo:" #'my:consult-gh--make-builder)
  )
#+end_src

#+RESULTS:
: my:consult-gh-async


** WIP
*** option1
#+begin_src emacs-lisp
(defvar my:consult-gh-args '("gh"))

;; (defun my:consult-gh--make-builder (input)
;;   "Build find command line, finding across PATHS."
;;   (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
;;                (`(,re . ,hl) (funcall consult--regexp-compiler arg 'basic t)))
;;     (cons (append (consult--build-args my:consult-gh-args) opts)
;;           hl)))

(defun my:consult-gh--make-builder (input)
  "Build command line from INPUT."
  (pcase-let ((`(,arg . ,opts) (consult--command-split input)))
    (unless (string-blank-p arg)
      (append (consult--build-args my:consult-gh-args)
              (list arg) opts))))

(defun my:consult-gh--async (prompt make-builder)
  (consult--read
     (consult--async-command make-builder
       :buffer (get-buffer-create "*consult-gh-output*") :stderr (get-buffer-create "*consult-gh-error*"))
     :prompt prompt
     :require-match nil
     :category 'consult-gh
     :sort nil))

(defun my:consult-gh-async ()
  (interactive)
  (let* ((my:consult-gh-args '("gh"))
         (arg1 (completing-read "Select Action: " '("repo" "issues" "search")))
         (arg2 (if (equal arg1 "search") (completing-read "Select Target: " '("repos" "issues")) nil))
         (my:consult-gh-args (append my:consult-gh-args (list arg1 arg2))))
    (print my:consult-gh-args)

  (my:consult-gh--async "Search Repo:" #'my:consult-gh--make-builder)
  ))

#+end_src

*** option2
#+begin_src emacs-lisp

(defun consult-gh-format-string (string width)
  (let* ((string (format "%s" string))
         (w (string-width string)))
    (when (< w width)
      (setq string (format "%s%s" (substring string) (make-string (- width w) ?\s))))
    (when (> w width)
      (setq string (format "%s..." (substring string 0 (- width (+ w 3))))))
    string))

(defun consult-gh-repo-lookup ()
  (lambda (sel cands &rest args)
    (plist-get (cdr (assoc sel cands)) :repo)))


(defun consult-gh-info-lookup ()
  (lambda (sel cands &rest args)
    (cdr (assoc sel cands))))

(defun my:consult-gh-state ()
  (lambda (action cand)
    (let* ((preview (consult--buffer-preview))
           )
      (if cand
          (pcase action
            ('return
             (funcall (funcall consult-gh-repo-action) (substring-no-properties (plist-get cand :repo)))
             )))
      )))

;; (defun my:consult-gh-state ()
;;   (lambda (action cand)
;;     (let ((preview (consult--buffer-preview)))
;;       (if cand
;;           (pcase action
;;             ;; ('preview
;;             ;;  (let ((repo (substring-no-properties cand))
;;             ;;        (buffer (get-buffer-create consult-gh-preview-buffer-name)))
;;             ;;    (add-to-list 'consult-gh--preview-buffers-list buffer)
;;             ;;    (consult-gh--repo-view repo buffer)
;;             ;;    (funcall preview action
;;             ;;             (and
;;             ;;              cand
;;             ;;              buffer
;;             ;;              )
;;             ;;             ))
;;         ('return
;;          (my:consult-gh-action cand)
;;          )
;;         )))
;;   ))



(defun my:consult-gh--parse (string)
  (let* ((parts (string-split string "\t"))
         (repo (car parts))
         (user (car (string-split repo "\/")))
         (description (cadr parts))
         (visibility (cadr (cdr parts)))
         (version (cadr (cdr (cdr parts))))
         )
    (propertize (format "%s\t%s\t%s\t%s"
                        (propertize (consult-gh-format-string repo 50) 'face 'consult-gh-default-face)
                        (propertize (consult-gh-format-string user 20) 'face 'consult-gh-user-face)
                        (propertize (consult-gh-format-string visibility 18) 'face 'consult-gh-visibility-face)
                        (propertize (consult-gh-format-string version 25) 'face 'consult-gh-date-face)) ':repo repo ':user user ':visible visibility ':description description ':version version)))

(defun my:consult-gh--parse (string)
  (let* ((lisp-indent-offset 1)
         (parts (string-split string "\t"))
         (repo (car parts))
         (user (car (string-split repo "\/")))
         (package (cadr (string-split repo "\/")))
         (description (cadr parts))
         (visibility (cadr (cdr parts)))
         (version (cadr (cdr (cdr parts))))
         )
    (cons (format "%s\s%s\s%s\s%s"
                  (consult-gh-format-string (concat (propertize user 'face 'consult-gh-user-face ) "/" (propertize package 'face 'consult-gh-package-face)) 40)
                  (propertize (consult-gh-format-string visibility 16) 'face 'consult-gh-visibility-face)
                  (propertize (consult-gh-format-string version 20) 'face 'consult-gh-date-face)
                  (propertize (consult-gh-format-string description 100) 'face 'consult-gh-description-face)) (list :repo repo :user user :version version :description description :visibile visibility))))

(defun my:consult-gh--highlight-match (cand)
  (let ((string (car cand)))
    ()))


(defun my:consult-gh--make-builder (input)
  "Build command line from INPUT."
  (pcase-let ((`(,arg . ,opts) (consult--command-split input)))
    (unless (string-blank-p arg)
      (append (consult--build-args my:consult-gh-args)
              (list arg) opts))))

(defun my:consult-gh--make-builder (input)
  "Build find command line, finding across PATHS."
  (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
               (`(,re . ,hl) (funcall consult--regexp-compiler arg 'pcre t)))
    (when re
      (cons (append (consult--build-args my:consult-gh-args)
                    (list (consult--join-regexps re 'pcre))
                    opts)
            hl))))


(defun my:consult-gh--make-builder (input)
  "Build find command line, finding across PATHS."
  (pcase-let* ((cmd (consult--build-args my:consult-gh-args))
               (`(,arg . ,opts) (consult--command-split input))
               (flags (append cmd opts)))
    (unless (or (member "-L" flags) (member "--limit" flags))
      (cond ((and (member "search" flags) (member "repos" flags))
             (setq cmd (append cmd (list "-L" (format "%s" consult-gh-repo-maxnum)))))
            ((and (member "search" flags) (member "issues" flags))
             (setq cmd (append cmd (list "-L" (format "%s" consult-gh-issue-maxnum)))))))
    (pcase-let* ((`(,re . ,hl) (funcall consult--regexp-compiler arg 'emacs t)))
      (when re
        (cons (append cmd
                      (list (consult--join-regexps re 'emacs))
                      opts)
              hl)))))

(defun my:consult-gh--async (prompt builder initial category)
  (consult--read
   (consult--async-command builder
     (consult--async-map (lambda (x) (my:consult-gh--parse x)))
     (consult--async-highlight builder))
   :prompt prompt
   :lookup (consult-gh-info-lookup)
   :state (funcall #'my:consult-gh-state)
   :initial (consult--async-split-initial initial)
   :group #'consult-gh--repo-group
   :add-history (consult--async-split-thingatpt 'symbol)
   :require-match t
   :category (make-symbol (concat "consult-gh-" category))
   :sort nil))


(defun my:consult-gh--async (prompt builder initial category)
  (consult--read
   (consult--async-command builder
     ;; (consult--async-highlight builder)
     ;; (consult--async-map (lambda (x) (my:consult-gh--highlight-match x)))
     (consult--async-map (lambda (x) (my:consult-gh--parse x)))
     ;; ;;(consult--grep-format builder)
     ;;(consult--async-transform my:consult-gh--parse)
     )
   :prompt prompt
   ;;:annotate (funcall #'my:consult-gh-annotate)
   :lookup (consult-gh-info-lookup)
   :state (funcall #'my:consult-gh-state)
   :initial (consult--async-split-initial initial)
   :group #'consult-gh--repo-group
   :add-history (consult--async-split-thingatpt 'symbol)
   :require-match t
   :category (make-symbol (concat "consult-gh-" category))
   :sort nil))

(defun my:consult-gh-async (&optional initial)
  (interactive "P")
  (let* ((my:consult-gh-args '("gh"))
         (arg1 (completing-read "Select Action: " '("repo" "issues" "search")))
         (arg2 (if (equal arg1 "search") (completing-read "Select Target: " '("repos" "issues")) nil))
         (my:consult-gh-args (append my:consult-gh-args (list arg1 arg2))))
    (my:consult-gh--async "Search Repo:  " #'my:consult-gh--make-builder initial arg1)
    ))
#+end_src

#+RESULTS:
: my:consult-gh-async

#+begin_src emacs-lisp :results verbatim drawer
(my:consult-gh--parse "armindarvish/consult-gh                 public  2023-09-21T15:05:51")
#+end_src

#+begin_src emacs-lisp
(string-split "armindarvish/consult-gh\tpublic\t2023-09-21T15:05:51" "\t")
#+end_src

#+RESULTS:
| armindarvish/consult-gh | public | 2023-09-21T15:05:51 |


:end:

#+begin_src emacs-lisp :results verbatim drawer
(my:consult-gh-async)
#+end_src

#+RESULTS:
:results:
(:repo #("armindarvish/consult-gh" 13 23 (face consult-highlight-match)) :user "armindarvish" :version "2023-09-21T20:09:52Z" :description "An Interactive interface for \"GitHub CLI\" client inside GNU Emacs using Consult" :visibile "public")
:end:




#+begin_src emacs-lisp :results verbatim drawer
(string-trim (car (string-split (my:consult-gh-async) "\t")) "\t+\\|\s+\\|\n" "\t+\\|\s+\\|\n")
#+end_src

#+begin_src emacs-lisp :results verbatim drawer
(plist-get (cdr (my:consult-gh-async)) :repo)
#+end_src


#+begin_src emacs-lisp :results verbatim drawer
(my:consult-gh-async)
#+end_src








* Old
** from codesearch
#+begin_src emacs-lisp
;;; consult-codesearch.el --- Consult interface for codesearch -*- lexical-binding: t; -*-

;; Copyright (C) 2022 Youngjoo Lee

;; Author: Youngjoo Lee <youngker@gmail.com>
;; URL: https://github.com/youngker/consult-codesearch
;; Version: 0.3
;; Keywords: tools
;; Package-Requires: ((emacs "27.1") (consult "0.20"))

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Consult interface for codesearch
;;
;; See documentation on https://github.com/youngker/consult-codesearch.el

;;; Code:

(require 'consult)

(defgroup consult-codesearch nil
  "Consult interface for codesearch."
  :prefix "consult-codesearch-"
  :group 'consult)

(defvar consult-codesearch--args nil
  "Codesearch arguments.")

(defvar consult-codesearch-buffer "*codesearch*"
  "Codesearch buffer.")

(defcustom consult-codesearch-csearchindex ".csearchindex"
  "Index file for each projects."
  :type 'string
  :group 'consult-codesearch)

(defcustom consult-codesearch-find-file-args
  "csearch -l -f"
  "Codesearch file search command."
  :type 'string
  :group 'consult-codesearch)

(defcustom consult-codesearch-grep-args
  "csearch -n"
  "Codesearch search command."
  :type 'string
  :group 'consult-codesearch)

(defconst consult-codesearch--match-regexp
  "\\`\\(?:\\./\\)?\\([^\n\0]+\\):\\([0-9]+\\)\\([-:\0]\\)"
  "Regexp used to match file and line of codesearch output.")

(defun consult-codesearch--builder (_paths)
  "Build command line given PATHS."
  (let ((cmd (consult--build-args consult-codesearch--args)))
    (lambda (input)
      (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
                   (flags (append cmd opts))
                   (files-with-matchs (member "-l" flags))
                   (ignore-case (member "-i" flags))
                   (`(,re . ,hl)
                    (funcall consult--regexp-compiler arg 'extended ignore-case)))
        (when re
          (cons (append cmd opts
                        (let ((jre (consult--join-regexps re 'extended)))
                          (if files-with-matchs
                              (list (concat "(?i)" jre) "$")
                            (list jre))))
                hl))))))

(defun consult-codesearch--set-index (dir)
  "Set CSEARCHINDEX variable in DIR."
  (let* ((start-dir (or dir default-directory))
         (index-dir (locate-dominating-file
                     start-dir consult-codesearch-csearchindex)))
    (if index-dir
        (setenv "CSEARCHINDEX"
                (expand-file-name (concat index-dir consult-codesearch-csearchindex)))
      (error "Can't find csearchindex"))))

;;;###autoload
(defun consult-codesearch-build-index (dir)
  "Create index file at DIR."
  (interactive "DIndex files in directory: ")
  (setenv "CSEARCHINDEX" (expand-file-name (concat dir consult-codesearch-csearchindex)))
  (let ((proc (apply 'start-process "codesearch"
                     consult-codesearch-buffer "cindex" (list (expand-file-name dir)))))
    (with-current-buffer consult-codesearch-buffer
      (pop-to-buffer consult-codesearch-buffer)
      (local-set-key (kbd "q") 'quit-window)
      (let ((buffer-read-only nil))
        (erase-buffer)))
    (set-process-filter
     proc
     (lambda (process output)
       (with-current-buffer (process-buffer process)
         (let ((buffer-read-only nil))
           (insert output)))))
    (set-process-sentinel
     proc
     (lambda (process event)
       (with-current-buffer (process-buffer process)
         (when (string= event "finished\n")
           (let ((buffer-read-only nil))
             (insert "\nIndexing finished"))
           (setq buffer-read-only t)))))))

;;;###autoload
(defun consult-codesearch (&optional dir)
  "Search with `codesearch' for files in DIR where the content matches a regexp.

The initial input is given by the INITIAL argument."
  (interactive "P")
  (let ((initial (substring-no-properties (or (thing-at-point 'symbol) "")))
        (consult-codesearch--args consult-codesearch-grep-args)
        (consult-async-refresh-delay 0.1)
        (consult-async-input-throttle 0)
        (consult-async-input-debounce 0)
        (consult--grep-match-regexp consult-codesearch--match-regexp)
        (_index (consult-codesearch--set-index dir)))
    (consult--grep "Codesearch" #'consult-codesearch--builder dir initial)))

;;;###autoload
(defun consult-codesearch-find-file (&optional dir)
  "Search for files in DIR matching input regexp given INITIAL input."
  (interactive "P")
  (let ((initial (substring-no-properties (or (thing-at-point 'symbol) "")))
        (consult-codesearch--args consult-codesearch-find-file-args)
        (consult-async-refresh-delay 0.1)
        (consult-async-input-throttle 0)
        (consult-async-input-debounce 0)
        (_index (consult-codesearch--set-index dir)))
    (pcase-let* ((`(,prompt ,paths ,dir) (consult--directory-prompt "Codesearch Find File" dir))
                 (default-directory dir)
                 (builder (consult-codesearch--builder paths)))
      (find-file (consult--find prompt builder initial)))))

(provide 'consult-codesearch)
;;; consult-codesearch.el ends here
#+end_src

#+RESULTS:
: consult-codesearch

** edit codesearch
#+begin_src emacs-lisp


(defvar consult-gh--args nil
  "Codesearch arguments.")

(defcustom consult-gh-grep-args
  "gh search issues --repo minad/vertico --state closed"
  "Codesearch search command."
  :type 'string
  :group 'consult-gh)

(defvar consult-gh-buffer "*consult-gh*"
  "Codesearch buffer.")

(defconst consult-gh--match-regexp
  "\\`\\(?:\\./\\)?\\([^\n\0]+\\):\\([0-9]+\\)\\([-:\0]\\)"
  "Regexp used to match file and line of codesearch output.")

(defun consult-gh--builder (repo)
  "Build command line given PATHS."
  (let ((cmd (consult--build-args consult-gh--args)))
    (lambda (input)
      (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
                   (flags (append cmd opts))
                   (files-with-matchs (member "-l" flags))
                   (ignore-case (member "-i" flags))
                   (`(,re . ,hl)
                    (funcall consult--regexp-compiler arg 'extended ignore-case)))
        (when re
          (cons (append cmd opts
                        (let ((jre (consult--join-regexps re 'extended)))
                          (if files-with-matchs
                              (list (concat "(?i)" jre) "$")
                            (list jre))))
                hl))))))

;; (defun consult-gh--set-index (dir)
;;   "Set CSEARCHINDEX variable in DIR."
;;   (let* ((start-dir (or dir default-directory))
;;          (index-dir (locate-dominating-file
;;                      start-dir consult-gh-csearchindex)))
;;     (if index-dir
;;         (setenv "CSEARCHINDEX"
;;                 (expand-file-name (concat index-dir consult-gh-csearchindex)))
;;       (error "Can't find csearchindex"))))

;;;###autoload
;; (defun consult-gh-build-index (dir)
;;   "Create index file at DIR."
;;   (interactive "DIndex files in directory: ")
;;   (setenv "CSEARCHINDEX" (expand-file-name (concat dir consult-gh-csearchindex)))
;;   (let ((proc (apply 'start-process "codesearch"
;;                      consult-gh-buffer "cindex" (list (expand-file-name dir)))))
;;     (with-current-buffer consult-gh-buffer
;;       (pop-to-buffer consult-gh-buffer)
;;       (local-set-key (kbd "q") 'quit-window)
;;       (let ((buffer-read-only nil))
;;         (erase-buffer)))
;;     (set-process-filter
;;      proc
;;      (lambda (process output)
;;        (with-current-buffer (process-buffer process)
;;          (let ((buffer-read-only nil))
;;            (insert output)))))
;;     (set-process-sentinel
;;      proc
;;      (lambda (process event)
;;        (with-current-buffer (process-buffer process)
;;          (when (string= event "finished\n")
;;            (let ((buffer-read-only nil))
;;              (insert "\nIndexing finished"))
;;            (setq buffer-read-only t)))))))

;;;###autoload
(defun consult-gh (&optional repo)
  "Search with `codesearch' for files in DIR where the content matches a regexp.

The initial input is given by the INITIAL argument."
  (interactive "P")
  (let ((initial (substring-no-properties (or (thing-at-point 'symbol) "")))
        (consult-gh--args consult-gh-grep-args)
        (consult-async-refresh-delay 0.1)
        (consult-async-input-throttle 0)
        (consult-async-input-debounce 0)
        (consult--grep-match-regexp consult-gh--match-regexp)
        ;;(_index (consult-gh--set-index dir))
        )
    (consult--grep "Search Issues:" #'consult-gh--builder repo "")))

;; ;;;###autoload
;; (defun consult-gh-find-file (&optional dir)
;;   "Search for files in DIR matching input regexp given INITIAL input."
;;   (interactive "P")
;;   (let ((initial (substring-no-properties (or (thing-at-point 'symbol) "")))
;;         (consult-gh--args consult-gh-find-file-args)
;;         (consult-async-refresh-delay 0.1)
;;         (consult-async-input-throttle 0)
;;         (consult-async-input-debounce 0)
;;         (_index (consult-gh--set-index dir)))
;;     (pcase-let* ((`(,prompt ,paths ,dir) (consult--directory-prompt "Codesearch Find File" dir))
;;                  (default-directory dir)
;;                  (builder (consult-gh--builder paths)))
;;       (find-file (consult--find prompt builder initial)))))

;; (provide 'consult-gh)
;;; consult-gh.el ends here
#+end_src

#+RESULTS:
: consult-gh
#+begin_src emacs-lisp
(consult--build-args "gh search issues --repo minad/vertico --state closed")
#+end_src

#+RESULTS:
| gh | search | issues | --repo | minad/vertico | --state | closed |
** consult-ripgrep
#+begin_src emacs-lisp
(defcustom consult-ripgrep-args
  "rg --null --line-buffered --color=never --max-columns=1000 --path-separator /\
   --smart-case --no-heading --with-filename --line-number --search-zip"
  "Command line arguments for ripgrep, see `consult-ripgrep'.
The dynamically computed arguments are appended.
Can be either a string, or a list of strings or expressions."
  :type '(choice string (repeat (choice string expression))))

(defun consult--grep (prompt make-builder dir initial)
  "Run asynchronous grep.

MAKE-BUILDER is the function that returns the command line
builder function.  DIR is a directory or a list of file or
directories.  PROMPT is the prompt string.  INITIAL is initial
input."
  (pcase-let* ((`(,prompt ,paths ,dir) (consult--directory-prompt prompt dir))
               (default-directory dir)
               (builder (funcall make-builder paths)))
    (consult--read
     (consult--async-command builder
       (consult--grep-format builder)
       :file-handler t) ;; allow tramp
     :prompt prompt
     :lookup #'consult--lookup-member
     :state (consult--grep-state)
     :initial (consult--async-split-initial initial)
     :add-history (consult--async-split-thingatpt 'symbol)
     :require-match t
     :category 'consult-grep
     :group #'consult--prefix-group
     :history '(:input consult--grep-history)
     :sort nil)))


;;;;; Command: consult-ripgrep

(defun consult--ripgrep-make-builder (paths)
  "Create ripgrep command line builder given PATHS."
  (let* ((cmd (consult--build-args consult-ripgrep-args))
         (type (if (consult--grep-lookahead-p (car cmd) "-P") 'pcre 'extended)))
    (lambda (input)
      (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
                   (flags (append cmd opts))
                   (ignore-case (if (or (member "-S" flags) (member "--smart-case" flags))
                                    (let (case-fold-search)
                                      ;; Case insensitive if there are no uppercase letters
                                      (not (string-match-p "[[:upper:]]" arg)))
                                  (or (member "-i" flags) (member "--ignore-case" flags)))))
        (if (or (member "-F" flags) (member "--fixed-strings" flags))
            (cons (append cmd (list "-e" arg) opts paths)
                  (apply-partially #'consult--highlight-regexps
                                   (list (regexp-quote arg)) ignore-case))
          (pcase-let ((`(,re . ,hl) (funcall consult--regexp-compiler arg type ignore-case)))
            (when re
              (cons (append cmd (and (eq type 'pcre) '("-P"))
                            (list "-e" (consult--join-regexps re type))
                            opts paths)
                    hl))))))))

;;;###autoload
(defun consult-ripgrep (&optional dir initial)
  "Search with `rg' for files in DIR with INITIAL input.
See `consult-grep' for details."
  (interactive "P")
  (consult--grep "Ripgrep" #'consult--ripgrep-make-builder dir initial))

#+end_src
** consult-gh-async
#+begin_src emacs-lisp

;;;;; Command: consult-gh-async
(defcustom consult-gh-async-args
  "gh search issues --repo minad/vertico --state=closed"
  "Command line arguments for ripgrep, see `consult-gh-async'.
The dynamically computed arguments are appended.
Can be either a string, or a list of strings or expressions."
  :type '(choice string (repeat (choice string expression))))

(defun consult--gh-make-builder (paths)
  "Create ripgrep command line builder given PATHS."
  (let* ((cmd (consult--build-args consult-gh-async-args)))
    (lambda (input)
      (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
                   (flags (append cmd opts))
                   (ignore-case (if (or (member "-S" flags) (member "--smart-case" flags))
                                    (let (case-fold-search)
                                      ;; Case insensitive if there are no uppercase letters
                                      (not (string-match-p "[[:upper:]]" arg)))
                                  (or (member "-i" flags) (member "--ignore-case" flags)))))
        (print flags)
        ;; (if (or (member "-F" flags) (member "--fixed-strings" flags))
        ;;     (cons (append cmd (list "-e" arg) opts paths)
        ;;           (apply-partially #'consult--highlight-regexps
        ;;                            (list (regexp-quote arg)) ignore-case))
        ;;   (pcase-let ((`(,re . ,hl) (funcall consult--regexp-compiler arg type ignore-case)))
        ;;     (when re
        ;;       (cons (append cmd (and (eq type 'pcre) '("-P"))
        ;;                     (list "-e" (consult--join-regexps re type))
        ;;                     opts paths)
        ;;             hl))))

))))

;;;###autoload
(defun consult-gh-async (&optional dir initial)
  "Search with `rg' for files in DIR with INITIAL input.
See `consult-grep' for details."
  (interactive "P")
  (consult--grep "gh:" #'consult--gh-make-builder dir initial))

#+end_src


#+begin_src emacs-lisp :results raw drawer
(funcall #'consult--gh-make-builder "~/projects/")
#+end_src



#+begin_src emacs-lisp
(consult--directory-prompt "gh:" nil)
#+end_src

#+RESULTS:
| gh: (Project consult-gh): | (.) | /Users/armin/projects/consult-gh/ |

#+begin_src emacs-lisp
 (pcase-let* ((`(,arg . ,opts) (consult--command-split "")))
   (print arg)
   (print opts))
#+end_src

#+RESULTS:
