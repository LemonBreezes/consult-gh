
* completing read virtual directory
#+begin_src emacs-lisp
(defun consult-gh--expand-file-path (path file-paths)
  "Expands the file path to show subdirectories and files based on the given path."
   (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                      file-paths))
             (sub-entries (cons "../" (mapcar (lambda (dir) (concat "." (substring dir (length parent-dir)))) sub-entries)))
             (sub-dirs (seq-filter (lambda (entry) (and (string-suffix-p "/" entry) (<= (length (string-split entry "\/")) 3))) sub-entries))
             (sub-files (seq-filter (lambda (entry) (and (not (string-suffix-p "/" entry)) (<= (length (string-split entry "\/")) 2) )) sub-entries))
             (sub-dirs (mapcar (lambda (dir) (propertize (file-name-directory dir) 'face 'consult-gh-visibility-face)) sub-dirs))
             (sub-files (mapcar (lambda (file) (propertize (file-name-nondirectory file) 'face 'consult-gh-default-face)) sub-files))
             (items (append sub-dirs sub-files)))
        items
        )

    '()))

(defun consult-gh--completing-read-file-path (prompt items root all-items)
  "Prompts the user to select a file path using dynamic expansion."
  (let* ((my:make-table (apply-partially #'completion-table-with-predicate
                                 #'completion-file-name-table
                                 t
                                 'strict))
         (my:table
          (completion-table-in-turn (delete-dups (sort items 'string<)) my:make-table))
         (path (completing-read prompt my:table (lambda (path) (all-completions root all-items)) t))
         (selected-path (consult-gh--expand-file-path (concat root (string-trim path "./")) all-items)))
    `(,path ,selected-path)
    ))

(defun consult-gh--completing-read-loop (prompt items root all-items)
  (while  items
    (setq res (my-completing-read-file-path (format "%s: " root) (consult-gh--expand-file-path root all-items) root all-items))
    (pcase (car res)
      ("./"
       (setq root (concat (string-join (butlast (butlast (string-split root "\/"))) "/") "/"))
       (setq items (cadr (consult-gh--expand-file-path root all-items)))
       )
      ("../"
       )
      (_
       (setq root (concat root (string-trim (car res) "./")))
       (setq items (cadr (consult-gh--expand-file-path root all-items)))
       (print root)
       (print items)))
    )
  (string-trim root "./"))

(defun consult-gh--completing-read-file-directory (repo branch prefix)
  (let* ((file-paths (append '("./") (mapcar (lambda (path)
                                       (unless (get-text-property 0 ':size path) (setq path (concat path "/")))
                                       (concat prefix path))
                                     (consult-gh--files-list-items repo branch))))
       (root (car (sort file-paths 'string<)))
       (items  (cl-sort (remove prefix (consult-gh--expand-file-path root file-paths)) 'string-lessp :key 'downcase)))

  (if items
     (my-completing-read-loop "Select file path:" items root file-paths)
    )))

#+end_src

#+begin_src emacs-lisp

#+end_src
* Working code
#+begin_src emacs-lisp
(defun consult-gh--expand-file-path (path file-paths)
  "Expands the file path to show subdirectories and files based on the given path."
   (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                      file-paths))
             (sub-entries (mapcar (lambda (dir) (concat "." (substring dir (length parent-dir)))) sub-entries))
             (sub-dirs (seq-filter (lambda (entry) (and (string-suffix-p "/" entry) (<= (length (string-split entry "\/")) 3))) sub-entries))
             (sub-files (seq-filter (lambda (entry) (and (not (string-suffix-p "/" entry)) (<= (length (string-split entry "\/")) 2) )) sub-entries))
             (sub-dirs (mapcar (lambda (dir) (propertize (file-name-directory dir) 'face 'consult-gh-visibility-face)) sub-dirs))
             (sub-files (mapcar (lambda (file) (propertize (file-name-nondirectory file) 'face 'consult-gh-default-face)) sub-files))
             (items (append sub-dirs sub-files)))
        items
        )

    '()))

(defun consult-gh--completing-read-file-path (prompt items root all-items)
  "Prompts the user to select a file path using dynamic expansion."
  (let* ((completion-cycle-threshold t)
         (consult-gh--make-table (apply-partially #'completion-table-with-predicate
                                 #'completion-file-name-table
                                 t
                                 'strict))
         (consult-gh--table (completion-table-in-turn (delete-dups (sort items 'string<)) consult-gh--make-table))
         (path (completing-read prompt consult-gh--table (lambda (path) (all-completions root all-items)) t ;;(string-trim (format "%s" root) "./")
                                ))
         ;; (path  (completing-read prompt (completion-table-in-turn (mapcar (lambda (el) (completion-file-name-table el t 'strict)))) (lambda (path) (all-completions root all-items)) t))
         (selected-path (consult-gh--expand-file-path (concat root (string-trim path "./")) all-items)))
    `(,path ,selected-path)
    ))

(defun consult-gh--completing-read-loop (prompt items root all-items)
  (while  items
    (setq res (consult-gh--completing-read-file-path "Select File: " (consult-gh--expand-file-path root all-items) root all-items))
    (pcase (car res)
      ("./"
       (setq root (concat (string-join (butlast (butlast (string-split root "\/"))) "/") "/"))
       (setq items (consult-gh--expand-file-path root all-items))
       )
      (_
       (setq root (concat root (string-trim (car res) "./")))
       (setq items (consult-gh--expand-file-path root all-items))
       (print root)
       (print items)
       ))
    )
  (string-trim root "./"))

(defun consult-gh--completing-read-file-directory (repo branch)
  (let* ((root "./")
         (file-paths (append `(,root) (mapcar (lambda (path)
                                       (unless (get-text-property 0 ':size path) (setq path (concat path "/")))
                                       (concat "./" path))
                                     (consult-gh--files-list-items repo branch))))
       (items  (cl-sort (remove "./" (consult-gh--expand-file-path root file-paths)) 'string-lessp :key 'downcase)))

  (if items
     (consult-gh--completing-read-loop "Select file path:" items root file-paths)
    )))

(consult-gh--completing-read-file-directory "minad/vertico" "main")

;; ;;Example usage:
;; (let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2"))
;;       (path "/foo/bar/"))
;;   ;;(completing-read "Select file path:" (completion-table-in-turn file-paths) )
;;   (consult-gh--completing-read-file-path "/foo/"  (consult-gh--expand-file-path path file-paths) path file-paths)
;; ;;(all-completions path file-paths)
;;   ;; (consult-gh--expand-file-path path file-paths)
;;   ;;(all-completions path file-paths)
;;   )
#+end_src
* tests
#+begin_src emacs-lisp
(defun consult-gh--expand-file-path (path file-paths)
  "Expands the file path to show subdirectories and files based on the given path."
   (if (string-suffix-p "/" path)
       (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                      file-paths))
             (sub-entries (mapcar (lambda (dir) (concat "." (substring dir (length parent-dir)))) sub-entries))
             (sub-dirs (seq-filter (lambda (entry) (and (string-suffix-p "/" entry) (<= (length (string-split entry "\/")) 3))) sub-entries))
             (sub-files (seq-filter (lambda (entry) (and (not (string-suffix-p "/" entry)) (<= (length (string-split entry "\/")) 2) )) sub-entries))
             (sub-dirs (mapcar (lambda (dir) (propertize (file-name-directory dir) 'face 'consult-gh-visibility-face)) sub-dirs))
             (sub-files (mapcar (lambda (file) (propertize (file-name-nondirectory file) 'face 'consult-gh-default-face)) sub-files))
             (items (append sub-dirs sub-files)))
        items
        )
    '()))

(defun consult-gh--completing-read-file-path (prompt items root all-items &optional prefix)
  "Prompts the user to select a file path using dynamic expansion."
  (let* (;(completion-cycle-threshold t)
         (prefix (concat (or prefix ".") "/"))
         (consult-gh--table (completion-table-in-turn (delete-dups (sort items 'string<)) #'completion-file-name-table))
         (path (consult--read consult-gh--table
                              :prompt prompt
                              :sort nil
                              ;;:predicate (lambda (path) (all-completions root all-items))
                              :require-match t
                              ;;(string-trim (format "%s" root) "./")
                                ))
         ;; (path  (completing-read prompt (completion-table-in-turn (mapcar (lambda (el) (completion-file-name-table el t 'strict)))) (lambda (path) (all-completions root all-items)) t))
         (selected-path (consult-gh--expand-file-path (concat root (string-trim path prefix)) all-items)))
    `(,path ,selected-path)
    ))

(defun consult-gh--completing-read-loop (prompt items root all-items &optional prefix)
 (let ((prefix (concat (or prefix ".") "/")))
  (while  items
    (setq res (consult-gh--completing-read-file-path "Select File: " items root all-items))
    (pcase (car res)
      ("./"
       (setq root (concat (string-join (butlast (butlast (string-split root "\/"))) "/") "/"))
       (setq items (remove root (consult-gh--expand-file-path root all-items)))
       )
      (_
       (setq root (concat root (string-trim (car res) prefix)))
       (setq items (consult-gh--expand-file-path root all-items))
       (print root)
       (print items)
       ))
    )
  (string-trim root prefix)))

(defun consult-gh--completing-read-file-directory (repo branch)
  (let* ((root "./")
         (file-paths (append `(,root) (mapcar (lambda (path)
                                       (unless (get-text-property 0 ':size path) (setq path (concat path "/")))
                                       (concat root path))
                                     (consult-gh--files-list-items repo branch))))
       ;(items  (cl-sort (remove root (consult-gh--expand-file-path root file-paths)) 'string-lessp :key 'downcase))
         (items (remove root (consult-gh--expand-file-path root file-paths)))
         )
  (if items
     (consult-gh--completing-read-loop "Select file path:" items root file-paths)
    )))

(consult-gh--completing-read-file-directory "numpy/numpy" "main")

;; ;;Example usage:
;; (let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2"))
;;       (path "/foo/bar/"))
;;   ;;(completing-read "Select file path:" (completion-table-in-turn file-paths) )
;;   (consult-gh--completing-read-file-path "/foo/"  (consult-gh--expand-file-path path file-paths) path file-paths)
;; ;;(all-completions path file-paths)
;;   ;; (consult-gh--expand-file-path path file-paths)
;;   ;;(all-completions path file-paths)
;;   )
#+end_src

#+begin_src emacs-lisp
(defun consult-gh--files-lookup (selected candidates &rest _)
(let ((list (all-completions selected candidates)))
  (if (> (length list) 1)
      (consult--read list :prompt "Select File: ")
    list)
))

(let* ((root "./")
       (repo "minad/vertico")
       (branch "main")
       (response (consult-gh--files-get-trees repo branch))
       (items (completion-table-dynamic (lambda (_) (completion-table-in-turn (delete-dups (consult-gh--files-hashtable-to-list (consult-gh--api-json-to-table (cadr response) "tree") repo branch)) #'completion-file-name-table)))
       ))
;(type-of items)
(consult--read items :prompt "Select Files: "
               :lookup )
;;(type-of items)
)

;; (defun consult--lookup-candidate (selected candidates &rest _)
;;   "Lookup SELECTED in CANDIDATES list and return property `consult--candidate'."
;;   (consult--lookup-prop 'consult--candidate selected candidates))

#+end_src

#+RESULTS:
: vertico.el

#+begin_src emacs-lisp :results raw

#+end_src

#+RESULTS:
(. .#consult-gh.org .#dir-expansion.org .. .git .gitignore LICENSE README.md README.org README.org~ consult-gh-embark.el consult-gh.el consult-gh.org consult-gh.org~ dir-expansion.org dir-expansion.org~)

#+begin_src emacs-lisp
(let* ((root "./")
       (repo "minad/vertico")
       (branch "main")
       (file-paths (append `(,root) (mapcar (lambda (path)
                                       (unless (get-text-property 0 ':size path) (setq path (concat path "/")))
                                       (concat root path))
                                     (consult-gh--files-list-items repo branch))))
       (items  (cl-sort (remove "./" (consult-gh--expand-file-path root file-paths)) 'string-lessp :key 'downcase)))
;(consult-gh--completing-read-file-path "Select: " file-paths root file-paths)
(consult-gh--files-list-items repo branch)
)
#+end_src

#+RESULTS:
| CHANGELOG.org | LICENSE | README.org | extensions | extensions/vertico-buffer.el | extensions/vertico-directory.el | extensions/vertico-flat.el | extensions/vertico-grid.el | extensions/vertico-indexed.el | extensions/vertico-mouse.el | extensions/vertico-multiform.el | extensions/vertico-quick.el | extensions/vertico-repeat.el | extensions/vertico-reverse.el | extensions/vertico-unobtrusive.el | vertico.el |

#+begin_src emacs-lisp
(defun consult-gh--expand-file-path (path file-paths)
  "Expands the file path to show subdirectories and files based on the given path."
   (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                      file-paths))
             (sub-entries (mapcar (lambda (dir) (concat "." (substring dir (length parent-dir)))) sub-entries))
             (sub-dirs (seq-filter (lambda (entry) (and (string-suffix-p "/" entry) (<= (length (string-split entry "\/")) 3))) sub-entries))
             (sub-files (seq-filter (lambda (entry) (and (not (string-suffix-p "/" entry)) (<= (length (string-split entry "\/")) 2) )) sub-entries))
             (sub-dirs (mapcar (lambda (dir) (propertize (file-name-directory dir) 'face 'consult-gh-visibility-face)) sub-dirs))
             (sub-files (mapcar (lambda (file) (propertize (file-name-nondirectory file) 'face 'consult-gh-default-face)) sub-files))
             (items (append sub-dirs sub-files)))
        items
        )

    '()))

(defun consult-gh--completing-read-file-path (prompt items root all-items)
  "Prompts the user to select a file path using dynamic expansion."
  (let* ((completion-cycle-threshold t)
         (consult-gh--make-table (apply-partially #'completion-table-with-predicate
                                 #'completion-file-name-table
                                 t
                                 'strict))
         (consult-gh--table (mapcar (lambda (str) (completion-file-name-table str t 'strict)) (delete-dups (sort items 'string<))))
         (path (completing-read prompt consult-gh--table (lambda (path) (all-completions root all-items)) t ;;(string-trim (format "%s" root) "./")
                                ))
         ;; (path  (completing-read prompt (completion-table-in-turn (mapcar (lambda (el) (completion-file-name-table el t 'strict)))) (lambda (path) (all-completions root all-items)) t))
         (selected-path (consult-gh--expand-file-path (concat root (string-trim path "./")) all-items)))
    `(,path ,selected-path)
    ))

(defun consult-gh--completing-read-loop (prompt items root all-items)
  (while  items
    (setq res (consult-gh--completing-read-file-path "Select File: " (consult-gh--expand-file-path root all-items) root all-items))
    (pcase (car res)
      ("./"
       (setq root (concat (string-join (butlast (butlast (string-split root "\/"))) "/") "/"))
       (setq items (consult-gh--expand-file-path root all-items))
       )
      (_
       (setq root (concat root (string-trim (car res) "./")))
       (setq items (consult-gh--expand-file-path root all-items))
       (print root)
       (print items)
       ))
    )
  (string-trim root "./"))

(defun consult-gh--completing-read-file-directory (repo branch)
  (let* ((root "./")
         (file-paths (append `(,root) (mapcar (lambda (path)
                                       (unless (get-text-property 0 ':size path) (setq path (concat path "/")))
                                       (concat "./" path))
                                     (consult-gh--files-list-items repo branch))))
       (items  (cl-sort (remove "./" (consult-gh--expand-file-path root file-paths)) 'string-lessp :key 'downcase)))

  (if items
     (consult-gh--completing-read-loop "Select file path:" items root file-paths)
    )))

(consult-gh--completing-read-file-directory "minad/vertico" "main")

;; ;;Example usage:
;; (let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2"))
;;       (path "/foo/bar/"))
;;   ;;(completing-read "Select file path:" (completion-table-in-turn file-paths) )
;;   (consult-gh--completing-read-file-path "/foo/"  (consult-gh--expand-file-path path file-paths) path file-paths)
;; ;;(all-completions path file-paths)
;;   ;; (consult-gh--expand-file-path path file-paths)
;;   ;;(all-completions path file-paths)
;;   )
#+end_src
#+begin_src emacs-lisp
(let* ((repo "minad/vertico")
      (branch "main")
      (root "./")
      ;; (items (append `(,root) (mapcar (lambda (path)
      ;;                                  (unless (get-text-property 0 ':size path) (setq path (concat path "/")))
      ;;                                  (concat "./" path))
      ;;                                (consult-gh--files-list-items repo branch))))
      (items '("/foo/" "/foo/file0" "/foo/file1" "/foo/bar/" "/foo/bar/file2" "/foo/bar/file3" "/foo/baz/" "/foo/baz/file4" "/foo/baz/file5"))
      (my:make-table (apply-partially #'completion-table-with-predicate
                                 #'completion-file-name-table
                                 t
                                 'strict))
         (my:table
          (completion-table-in-turn (delete-dups (sort items 'string<)) my:make-table)))

(completing-read "Select File: " my:table)
;; (consult--read my:table :prompt "Select File: " :lookup)
)
#+end_src

#+begin_src emacs-lisp
(let* ((repo "minad/vertico")
      (branch "main")
      (root "./")
      ;; (items (append `(,root) (mapcar (lambda (path)
      ;;                                  (unless (get-text-property 0 ':size path) (setq path (concat path "/")))
      ;;                                  (concat "./" path))
      ;;                                (consult-gh--files-list-items repo branch))))
      (items '("/foo/" "/foo/file0" "/foo/file1" "/foo/bar/" "/foo/bar/file2" "/foo/bar/file3" "/foo/baz/" "/foo/baz/file4" "/foo/baz/file5"))
      (my:make-table #'completion-file-name-table)
         (my:table
          (completion-table-in-turn items)))

(completing-read "Select File: " my:table)
;; (consult--read my:table :prompt "Select File: " :lookup)
)
#+end_src

#+begin_src emacs-lisp
                      (completing-read prompt 'read-file-name-internal
                                       pred mustmatch insdef
                                       'file-name-history default-filename)))
                ;; If DEFAULT-FILENAME not supplied and DIR contains
  (completion-table-in-turn #'completion--embedded-envvar-table
                            #'completion--file-name-table)

#+end_src
#+RESULTS:
: /foo/

#+begin_src emacs-lisp
(defun my-completion-function (prefix nil t)
  ;; You can just ignore the prefix
  (let* ((items '("/foo/" "/foo/file0" "/foo/file1" "/foo/bar/" "/foo/bar/file2" "/foo/bar/file3" "/foo/baz/" "/foo/baz/file4" "/foo/baz/file5")))
    (completion-table-dynamic (all-completions prefix items))
  ))

(completing-read "Select One:" #'my-completion-function)

;; (let* ((items '("/foo/" "/foo/file0" "/foo/file1" "/foo/bar/" "/foo/bar/file2" "/foo/bar/file3" "/foo/baz/" "/foo/baz/file4" "/foo/baz/file5")))
;; (completing-read "Chose one: "
;;                  (completion-table-dynamic (apply-partially #'my-completion-function items))))

;; (completing-read "Choose One: " (completion-table-dynamic  '("/foo/" "/foo/file0" "/foo/file1" "/foo/bar/" "/foo/bar/file2" "/foo/bar/file3" "/foo/baz/" "/foo/baz/file4" "/foo/baz/file5")))
#+end_src

#+begin_src emacs-lisp
(completion-table-dynamic (all-completions "/foo/bar/"'("/foo/" "/foo/file0" "/foo/file1" "/foo/bar/" "/foo/bar/file2" "/foo/bar/file3" "/foo/baz/" "/foo/baz/file4" "/foo/baz/file5")))
#+end_src
#+RESULTS:
: #[771 "\211\242\302=\206
:  \211\303=?\2054 r\300\204 p\202) \304 \305!\203' \306!\262\202) \210pq\210\307\301!$)\207" [nil ("/foo/bar/" "/foo/bar/file2" "/foo/bar/file3") boundaries metadata minibuffer-selected-window window-live-p window-buffer complete-with-action] 8 "
:
: (fn STRING PRED ACTION)"]


* from stackoverflow
#from [[https://emacs.stackexchange.com/questions/21304/completing-read-a-directory-or-an-element-from-a-list][completion - Completing read a directory or an element from a list - Emacs Stack Exchange]]:

#+begin_src emacs-lisp
(let* ((my:make-table (apply-partially #'completion-table-with-predicate
                                 #'completion-file-name-table
                                 t
                                 'strict))
       (my:table
        (completion-table-in-turn (delete-dups (sort '("file0" "/foo/" "/foo/bar/" "/foo/bar/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/baz/file3") 'string<)) my:make-table)))
  (completing-read "Foo:" my:table))

#+end_src

#+begin_src emacs-lisp
(let* ((my:make-table (apply-partially #'completion-table-with-predicate
                                       #'completion-file-name-table
                                       t
                                       'strict))
       (my:table
 (let* ((top-level-dirs '("/foo/"))
        (my:make-table (apply-partially
                        #'completion-table-with-predicate
                        #'file-directory-p
                        top-level-dirs))
        (selected-dir (completing-read "Foo:" top-level-dirs nil t)))
   (if (string-equal selected-dir "/foo/")
       (let ((sub-dirs '("bar/" "file0" "baz/")))
         (completion-table-in-turn
          (mapcar (lambda (dir)
                    (concat selected-dir dir))
                  sub-dirs)
          my:make-table))
     '()))))

(completing-read "Foo:" my:table))

#+end_src

#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files."
  (if (file-directory-p path)
      (let ((sub-dirs (directory-files path nil directory-files-no-dot-files-regexp)))
        (completion-table-in-turn
         (mapcar (lambda (dir)
                   (concat (file-name-as-directory path) dir))
                 sub-dirs)
         #'file-directory-p))
    '()))

(let* ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/baz/file2"))
       (my:make-table (apply-partially
                       #'completion-table-with-predicate
                       #'file-directory-p
                       file-paths))
       (selected-path (completing-read "Select file path:" file-paths nil t)))
  (expand-file-path selected-path)
(completing-read "Foo:" my:table))
#+end_src

#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files."
  (if (file-directory-p path)
      (let ((sub-dirs (directory-files path nil directory-files-no-dot-files-regexp)))
        (completion-table-in-turn
         (mapcar (lambda (dir)
                   (concat (file-name-as-directory path) dir))
                 sub-dirs)
         #'file-directory-p))
    '()))

(let* ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/baz/file2"))
       (my:make-table (apply-partially
                       #'completion-table-with-predicate
                       (lambda (cand) (and (file-directory-p cand) (eq 1 (length (string-split cand "\/")))))
                       file-paths))
       (selected-path (completing-read "Select file path:" file-paths nil t)))
  (expand-file-path selected-path)
(completing-read "Foo:" my:table))
#+end_src

#+begin_src emacs-lisp
(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (defun expand-file-path (path)
    "Expands the file path to show subdirectories and files."
    (if (file-directory-p path)
        (let ((sub-dirs (directory-files path nil directory-files-no-dot-files-regexp)))
          (completion-table-in-turn
           (mapcar (lambda (dir)
                     (concat (file-name-as-directory path) dir))
                   sub-dirs)
           #'file-directory-p))
      '()))

  (let* ((my:make-table (apply-partially
                         #'completion-table-with-predicate
                         #'file-directory-p
                         file-paths))
         (my:table (mapcar #'expand-file-path file-paths))
         (selected-path (completing-read prompt my:table)))
    selected-path))

;; Example usage:
(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/")))
  (my-completing-read-file-path "Select file path:" file-paths))

#+end_src

#+RESULTS:
: nil

#+begin_src emacs-lisp
(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (defun expand-file-path (path)
    "Expands the file path to show subdirectories and files based on the given path."
    (if (string-suffix-p "/" path)
        (let ((sub-dirs (seq-filter (lambda (entry) (string-prefix-p path entry))
                                    file-paths)))
          (completion-table-in-turn
           (mapcar (lambda (dir)
                     (concat path dir))
                   sub-dirs)
           #'file-directory-p
           'strict))
      '()))

  (let* ((my:make-table (apply-partially
                         #'completion-table-with-predicate
                         #'file-directory-p
                         file-paths
                         'strict))
         (selected-path (completing-read prompt file-paths nil t)))
    (expand-file-path selected-path)))

;; Example usage:
(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/baz/file2")))
  (my-completing-read-file-path "Select file path:" file-paths))

#+end_src

#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (file-name-directory (substring path 0 -1)))
             (sub-dirs (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                   file-paths)))
        (completion-table-in-turn
         (mapcar (lambda (dir)
                   (concat path (substring dir (length parent-dir))))
                 sub-dirs)
         (lambda (cand) (and (file-directory-p cand) (eq 1 (length (string-split cand "\/")))))))
    '()))

(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (let* ((my:make-table (apply-partially
                         #'completion-table-with-predicate
                         (lambda (cand) (and (file-directory-p cand) (eq 1 (length (string-split cand "\/")))))
                         file-paths))
         (selected-path (completing-read prompt file-paths nil t)))
    (expand-file-path selected-path)))

;; Example usage:
(let ((file-paths '("file0" "/foo/" "/foo/bar/" "/foo/file1" "/foo/baz/" "/foo/baz/file2")))
  (my-completing-read-file-path "Select file path:" file-paths))

#+end_src

#+RESULTS:


* from chatgpt
#+begin_src emacs-lisp
(defun my:directory-paths-to-completion-table (paths)
  "Convert a list of directory paths to a file completion table."
  (let* ((table (make-hash-table :test 'equal))
         (prefix "")
         (insertion-fn (lambda (path)
                         (let* ((components (split-string (directory-file-name path) "/"))
                                (len (length components)))
                           (dolist (comp components)
                             (let ((key (concat prefix comp)))
                               (puthash key (if (= (1+ len) (length key))
                                                path
                                              (concat key "/"))
                                        table))))
                         (setq prefix (if (string-suffix-p "/" path) path (concat path "/"))))))
    (dolist (path (sort paths 'string<))
      (funcall insertion-fn path))
    (setq prefix (if (hash-table-empty-p table) "" prefix))
    (nconc (mapcar #'identity (hash-table-keys table))
           (list (concat prefix "*")))
    table))

(let* (table (my:directory-paths-to-completion-table '("/file0" "/foo/" "/foo/bar/" "/foo/file1" "/foo/file2" "/foo/baz/" "/foo/baz/file3" "/foo/baz/file4" "/spam/" "/spam/eggs" "/spam/ham"))
             (my:make-table (apply-partially #'completion-table-with-predicate
                                 #'completion-file-name-table
                                 #'file-directory-p
                                 'strict))
       (my:table
        (completion-table-in-turn table my:make-table)))
  (completing-read "Foo:" my:table))

(setq my:test  (my:directory-paths-to-completion-table '("/file0" "/foo/" "/foo/bar/" "/foo/file1" "/foo/file2" "/foo/baz/" "/foo/baz/file3" "/foo/baz/file4" "/spam/" "/spam/eggs" "/spam/ham")))
#+end_src


#+begin_src emacs-lisp
(defun create-dired-buffer (path-list)
  (with-current-buffer (get-buffer-create "*My Dired*")
    (dired-mode)
    (dired-mark-files-regexp "^\\.\\|\\.\\.$" t)
    (dired-do-kill-lines)
    (dolist (path path-list)
      (find-file-noselect path))
    (current-buffer)))

(let ((path-list '("/path/to/file1" "/path/to/file2" "/path/to/directory")))
  (pop-to-buffer (create-dired-buffer path-list)))
#+end_src

#+RESULTS:
: #<buffer *My Dired*>

#+begin_src emacs-lisp
(defun create-directory-completion-table (path-list)
    (completion-table-dynamic
     (lambda (input)
       (seq-filter (lambda (dir)
                     (string-prefix-p input dir))
                   (mapcar #'file-name-as-directory path-list)))))

(let* ((path-list '("/path/to/file1" "/path/to/file2" "/path/to/directory/"))
       (completion-table (create-directory-completion-table path-list)))
    (completing-read "Select directory: " completion-table))

;; (mapcar #'file-name-as-directory '("/path/to/file1" "/path/to/file2" "/path/to/directory/"))

;; (seq-filter #'file-directory-p '("/path/to/file1" "/path/to/file2" "/path/to/directory/"))
#+end_src

#+begin_src emacs-lisp
(defun create-completion-table (paths)
  "Create a completion table from a list of non-existing paths."
  (let ((completion-table '()))
    (dolist (path paths)
      (setq completion-table
            (completion-table-in-turn
             (lambda (input)
               (let ((completions '()))
                 (dolist (existing-path (directory-files default-directory))
                   (when (string-prefix-p input existing-path)
                     (push existing-path completions)))
                 completions))
             completion-table)))
    completion-table))

;; Example usage
(let ((paths '("/non-existing/path1" "/non-existing/path2" "/non-existing/path3")))
  (completing-read "Choose a path: " (create-completion-table paths)))


#+end_src

#+RESULTS:
: create-completion-table

#+begin_src emacs-lisp
(defun read-file-name-default (prompt &optional dir default-filename mustmatch initial predicate)
  "Default method for reading file names.
See `read-file-name' for the meaning of the arguments."
  (unless dir (setq dir (or default-directory "~/")))
  (unless (file-name-absolute-p dir) (setq dir (expand-file-name dir)))
  (unless default-filename
    (setq default-filename
          (cond
           ((null initial) buffer-file-name)
           ;; Special-case "" because (expand-file-name "" "/tmp/") returns
           ;; "/tmp" rather than "/tmp/" (bug#39057).
           ((equal "" initial) dir)
           (t (expand-file-name initial dir)))))
  ;; If dir starts with user's homedir, change that to ~.
  (setq dir (abbreviate-file-name dir))
  ;; Likewise for default-filename.
  (if default-filename
      (setq default-filename
	    (if (consp default-filename)
		(mapcar 'abbreviate-file-name default-filename)
	      (abbreviate-file-name default-filename))))
  (let ((insdef (cond
                 ((and insert-default-directory (stringp dir))
                  (if initial
                      (cons (minibuffer-maybe-quote-filename (concat dir initial))
                            (length (minibuffer-maybe-quote-filename dir)))
                    (minibuffer-maybe-quote-filename dir)))
                 (initial (cons (minibuffer-maybe-quote-filename initial) 0)))))

    (let ((ignore-case read-file-name-completion-ignore-case)
          (minibuffer-completing-file-name t)
          (pred (or predicate 'file-exists-p))
          (add-to-history nil))

      (let* ((val
              (if (or (not (next-read-file-uses-dialog-p))
                      ;; Graphical file dialogs can't handle remote
                      ;; files (Bug#99).
                      (file-remote-p dir))
                  ;; We used to pass `dir' to `read-file-name-internal' by
                  ;; abusing the `predicate' argument.  It's better to
                  ;; just use `default-directory', but in order to avoid
                  ;; changing `default-directory' in the current buffer,
                  ;; we don't let-bind it.
                  (let ((dir (file-name-as-directory
                              (expand-file-name dir))))
                    (minibuffer-with-setup-hook
                        (lambda ()
                          (setq default-directory dir)
                          ;; When the first default in `minibuffer-default'
                          ;; duplicates initial input `insdef',
                          ;; reset `minibuffer-default' to nil.
                          (when (equal (or (car-safe insdef) insdef)
                                       (or (car-safe minibuffer-default)
                                           minibuffer-default))
                            (setq minibuffer-default
                                  (cdr-safe minibuffer-default)))
                          (setq-local completion-ignore-case ignore-case)
                          ;; On the first request on `M-n' fill
                          ;; `minibuffer-default' with a list of defaults
                          ;; relevant for file-name reading.
                          (setq-local minibuffer-default-add-function
                               (lambda ()
                                 (with-current-buffer
                                     (window-buffer (minibuffer-selected-window))
				   (read-file-name--defaults dir initial))))
			  (set-syntax-table minibuffer-local-filename-syntax))
                      (completing-read prompt 'read-file-name-internal
                                       pred mustmatch insdef
                                       'file-name-history default-filename)))
                ;; If DEFAULT-FILENAME not supplied and DIR contains
                ;; a file name, split it.
                (let ((file (file-name-nondirectory dir))
                      ;; When using a dialog, revert to nil and non-nil
                      ;; interpretation of mustmatch. confirm options
                      ;; need to be interpreted as nil, otherwise
                      ;; it is impossible to create new files using
                      ;; dialogs with the default settings.
                      (dialog-mustmatch
                       (not (memq mustmatch
                                  '(nil confirm confirm-after-completion)))))
                  (when (and (not default-filename)
                             (not (zerop (length file))))
                    (setq default-filename file)
                    (setq dir (file-name-directory dir)))
                  (when default-filename
                    (setq default-filename
                          (expand-file-name (if (consp default-filename)
                                                (car default-filename)
                                              default-filename)
                                            dir)))
                  (setq add-to-history t)
                  (x-file-dialog prompt dir default-filename
                                 dialog-mustmatch
                                 (eq predicate 'file-directory-p)))))

             (replace-in-history (eq (car-safe file-name-history) val)))
        ;; If completing-read returned the inserted default string itself
        ;; (rather than a new string with the same contents),
        ;; it has to mean that the user typed RET with the minibuffer empty.
        ;; In that case, we really want to return ""
        ;; so that commands such as set-visited-file-name can distinguish.
        (when (consp default-filename)
          (setq default-filename (car default-filename)))
        (when (eq val default-filename)
          ;; In this case, completing-read has not added an element
          ;; to the history.  Maybe we should.
          (if (not replace-in-history)
              (setq add-to-history t))
          (setq val ""))
        (unless val (error "No file name specified"))

        (if (and default-filename
                 (string-equal val (if (consp insdef) (car insdef) insdef)))
            (setq val default-filename))
        (setq val (substitute-in-file-name val))

        (if replace-in-history
            ;; Replace what Fcompleting_read added to the history
            ;; with what we will actually return.  As an exception,
            ;; if that's the same as the second item in
            ;; file-name-history, it's really a repeat (Bug#4657).
            (let ((val1 (minibuffer-maybe-quote-filename val)))
              (if history-delete-duplicates
                  (setcdr file-name-history
                          (delete val1 (cdr file-name-history))))
              (if (string= val1 (cadr file-name-history))
                  (pop file-name-history)
                (setcar file-name-history val1)))
          (when add-to-history
            (add-to-history 'file-name-history
                            (minibuffer-maybe-quote-filename val))))
	val))))

#+end_src

#+begin_src emacs-lisp
(minibuffer-maybe-quote-filename "foo/bar/file")
(abbreviate-file-name "/foo/bar/file")
#+end_src

#+RESULTS:
: foo/bar/file


#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-dirs (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                   file-paths)))
        (completion-table-in-turn
         (mapcar (lambda (dir)
                   (concat path (substring dir (length parent-dir))))
                 (cons "." (cons ".." sub-dirs)))
         #'file-directory-p))
    '()))

(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (let* ((my:make-table (apply-partially
                         #'completion-table-with-predicate
                         #'file-directory-p
                         file-paths))
         (selected-path (completing-read prompt my:make-table)))
    (expand-file-path selected-path)))

;; Example usage:
(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/")))
  (my-completing-read-file-path "Select file path:" file-paths))

#+end_src

#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-dirs (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                   file-paths)))
        (completion-table-in-turn
         (mapcar (lambda (dir)
                   (concat path (substring dir (length parent-dir))))
                 (cons "." (cons ".." sub-dirs)))
         #'identity))
    '()))

(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (let* ((my:make-table (apply-partially
                         #'completion-table-with-predicate
                         #'file-directory-p
                         file-paths))
         (selected-path (completing-read prompt my:make-table)))
    (expand-file-path selected-path)))

;; Example usage:
(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/")))
  (my-completing-read-file-path "Select file path:" file-paths))

#+end_src

#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-dirs (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                   file-paths)))
        (completion-table-in-turn
         (mapcar (lambda (dir)
                   (concat path (substring dir (length parent-dir))))
                 (cons "." (cons ".." sub-dirs)))
        #'file-directory-p
         t
         ))
    '()))

(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (let* ((selected-path (completing-read prompt file-paths #'expand-file-path)))
    selected-path))

;; Example usage:
(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/")))
  (my-completing-read-file-path "Select file path:" file-paths))

#+end_src

#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-dirs (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                   file-paths)))
        (completion-table-in-turn
          (cons ".." (mapcar (lambda (dir) (concat "." (substring dir (length parent-dir)))) sub-dirs))
        #'file-directory-p
         t
         ))
    '()))

(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (let* ((selected-path (completing-read prompt file-paths #'expand-file-path)))
    selected-path))

;; Example usage:
(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2" "/foo/baz/file3")))
  (my-completing-read-file-path "Select file path:" file-paths))

#+end_src

#+RESULTS:
: /foo/


#+begin_src emacs-lisp :results raw
(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2" "/foo/baz/file3"))
      (path "/foo/"))
 (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                   file-paths))
             (sub-entries (cons ".." (mapcar (lambda (dir) (concat "." (substring dir (length parent-dir)))) sub-entries)))
             (sub-dirs (seq-filter (lambda (entry) (seq-filter #'file-directory-p sub-entries)
)
        sub-entries
        )))

        ;; (completion-table-in-turn
        ;;  (mapcar (lambda (dir)
        ;;            (concat path (substring dir (length parent-dir) -1)))
        ;;          (cons "." (cons ".." sub-dirs)))))))

#+end_src








#+begin_src emacs-lisp
(consult-gh--files-list-items "minad/vertico")

#+end_src

#+RESULTS:
| CHANGELOG.org | LICENSE | README.org | extensions | extensions/vertico-buffer.el | extensions/vertico-directory.el | extensions/vertico-flat.el | extensions/vertico-grid.el | extensions/vertico-indexed.el | extensions/vertico-mouse.el | extensions/vertico-multiform.el | extensions/vertico-quick.el | extensions/vertico-repeat.el | extensions/vertico-reverse.el | extensions/vertico-unobtrusive.el | vertico.el |



#+begin_src emacs-lisp
(all-completions "/bar/" '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2" "/foo/baz/file3"))
#+end_src

#+RESULTS:

#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                      file-paths))
             (sub-dirs (seq-filter (lambda (entry) (and (file-directory-p entry)
                                                       (string-prefix-p parent-dir entry)
                                                       (not (string= entry path))))
                                   sub-entries))
             (sub-files (seq-filter (lambda (entry) (and (not (file-directory-p entry))
                                                        (string-prefix-p parent-dir entry)))
                                    sub-entries)))
        (completion-table-in-turn
         (cons ".." (mapcar (lambda (dir) (concat "." (substring dir (length parent-dir)))) sub-dirs))
         sub-files))
    '()))


(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (let ((selected-path (completing-read prompt file-paths #'expand-file-path)))
    (if (string-suffix-p "/" selected-path)
        (my-completing-read-file-path (concat selected-path ".") file-paths)
      selected-path)))

(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2" "/foo/baz/file3")))
  (my-completing-read-file-path "Select file path:" file-paths))

#+end_src

#+RESULTS:
: /foo/bar/file1


#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p parent-dir entry))
                                      file-paths))
             (sub-dirs (seq-filter #'file-directory-p sub-entries))
             (sub-files (seq-filter (lambda (entry) (not (file-directory-p entry))) sub-entries)))
        (completion-table-in-turn
         (cons ".." (mapcar (lambda (dir) (concat "." (substring dir (length parent-dir)))) sub-dirs))
         (append sub-dirs sub-files)))
    (list path)))


(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (let ((selected-path (completing-read prompt file-paths #'expand-file-path)))
    (if (string-suffix-p "/" selected-path)
        (my-completing-read-file-path (concat selected-path ".") file-paths)
      selected-path)))

(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2" "/foo/baz/file3")))
  (my-completing-read-file-path "Select file path:" file-paths))
#+end_src


#+begin_src emacs-lisp
(defun expand-file-path (path file-paths)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p path entry))
                                      file-paths))
             (sub-dirs (seq-filter (lambda (entry) (and (file-directory-p entry)
                                                       (string-prefix-p path entry)))
                                   sub-entries))
             (sub-files (seq-filter (lambda (entry) (and (not (file-directory-p entry))
                                                        (string-prefix-p path entry)))
                                    sub-entries)))
        (completion-table-in-turn
         (cons ".." (mapcar (lambda (dir) (concat "." (substring dir (length path)))) sub-dirs))
         (mapcar (lambda (file) (substring file (length path))) sub-files)))
    '()))

(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (let ((selected-path (completing-read prompt file-paths (lambda (path) (expand-file-path path file-paths)))))
    (if (string-suffix-p "/" selected-path)
        (my-completing-read-file-path (concat selected-path ".") file-paths)
      selected-path)))

(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2" "/foo/baz/file3")))

  (my-completing-read-file-path "Select file path:" file-paths)
  ;;(expand-file-path "/fpp/bar/" file-paths
)
#+end_src

#+RESULTS:
: #[771 "\301\302\303$\300\"\207" [(("..") nil) completion--some make-closure #[257 "\303\300\302\301$\207" [V0 V1 V2 complete-with-action] 6 "
:
: (fn TABLE)"]] 9 "
:
: (fn STRING PRED ACTION)"]
#+begin_src emacs-lisp
(defun expand-file-path (path)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p path entry))
                                      file-paths))
             (sub-dirs (seq-filter (lambda (entry) (and (file-directory-p entry)
                                                       (string-prefix-p path entry)
                                                       (not (string= entry path))))
                                   sub-entries))
             (sub-files (seq-filter (lambda (entry) (and (not (file-directory-p entry))
                                                        (string-prefix-p path entry)))
                                    sub-entries)))
        (completion-table-in-turn
(append (list "..") (mapcar (lambda (dir) (concat "." (substring dir (length path)) "/")) sub-dirs)
                sub-files)))
    '()))


(defun my-completing-read-file-path (prompt file-paths)
  "Prompts the user to select a file path using dynamic expansion."
  (let ((selected-path (completing-read prompt file-paths #'expand-file-path)))
    (if (string-suffix-p "/" selected-path)
        (my-completing-read-file-path (concat selected-path ".") file-paths)
      selected-path)))

;; Example usage:
(let ((file-paths '("/foo/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/bar/file1" "/foo/bar/file2" "/foo/baz/file3")))
  (my-completing-read-file-path "Select file path:" file-paths))

#+end_src

#+begin_src emacs-lisp
(defun expand-file-path (path file-paths)
  "Expands the file path to show subdirectories and files based on the given path."
  (if (string-suffix-p "/" path)
      (let* ((parent-dir (substring path 0 -1))
             (sub-entries (seq-filter (lambda (entry) (string-prefix-p path entry))
                                      file-paths))
             (sub-dirs (seq-filter (lambda (entry) (and (file-directory-p entry)
                                                       (string-prefix-p path entry)
                                                       (not (string= entry path))))
                                   sub-entries))
             (sub-files (seq-filter (lambda (entry) (and (not (file-directory-p entry))
                                                        (string-prefix-p path entry)))
                                    sub-entries)))
        (completion-table-in-turn
(append (list "..") (mapcar (lambda (dir) (concat "." (substring dir (length path)) "/")) sub-dirs)
                sub-files)))
    '()))



(let* ((file-paths '("file0" "/foo/" "/foo/bar/" "/foo/bar/" "/foo/bar/" "/foo/file0" "/foo/baz/" "/foo/baz/file3"))
       (my:make-table (apply-partially #'completion-table-with-predicate
                                 #'completion-file-name-table
                                 #'expand-file-path
                                 'strict))
       (my:table
        (completion-table-in-turn (mapcar (lambda (path) (expand-file-path path file-paths)) file-paths) my:make-table)))
  (completing-read "Foo:" my:table))
#+end_src

*

* extra tests
#+begin_src emacs-lisp
(completion-file-name-table "/foo/bar/" t 'strict)
#+end_src

#+RESULTS:
